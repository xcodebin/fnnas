#!/bin/bash
#================================================================================================
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.
#
# This file is a part of the remake fnnas
# https://github.com/ophub/fnnas
#
# Description: Automatically Packaged fnnas
# Copyright (C) 2025~ https://fnnas.com
# Copyright (C) 2020~ https://github.com/unifreq/openwrt_packit
# Copyright (C) 2021~ https://github.com/ophub/amlogic-s9xxx-armbian/blob/main/CONTRIBUTORS.md
# Copyright (C) 2026~ https://github.com/ophub/fnnas
#
# Command: sudo ./renas
# Command optional parameters please refer to the source code repository
#
#======================================== Functions list ========================================
#
# error_msg          : Output error message
# process_msg        : Output process message
# mount_try          : Mount the image file, fail again
# get_textoffset     : Get kernel TEXT_OFFSET
#
# init_var           : Initialize all variables
# check_data         : Check the validity of the data
# find_fnnas         : Find fnnas file (fnnas-arm64/*.img.xz)
# git_pull_dir       : Download the files from the git repository
# download_depends   : Download the dependency files
# query_kernel       : Query the latest kernel version
# check_kernel       : Check kernel files integrity
# download_kernel    : Download the latest kernel
#
# confirm_version    : Confirm version type
# extract_fnnas      : Extract fnnas files
# make_image         : Making fnnas file
# copy_files         : Copy the fnnas files
# replace_kernel     : Replace the kernel
# refactor_bootfs    : Refactor bootfs files
# refactor_rootfs    : Refactor rootfs files
# clean_tmp          : Clear temporary files
#
# loop_make          : Loop to make fnnas
#
#================================ Set make environment variables ================================
#
# Related file storage path
current_path="${PWD}"
make_path="${current_path}/fnnas"
tmp_path="${make_path}/tmp"
out_path="${make_path}/out"
fnnas_path="${current_path}/fnnas-arm64"
fnnas_renas_file="*.img"
resource_path="${current_path}/make-fnnas"
kernel_path="${resource_path}/kernel"
uboot_path="${resource_path}/u-boot"
common_files="${resource_path}/fnnas-files/common-files"
platform_files="${resource_path}/fnnas-files/platform-files"
different_files="${resource_path}/fnnas-files/different-files"
firmware_path="${common_files}/usr/lib/firmware"
model_conf="${common_files}/etc/model_database.conf"
tmp_outpath="${tmp_path}/tmp_out"
tmp_fnnas="${tmp_path}/tmp_fnnas"
tmp_build="${tmp_path}/tmp_build"
tmp_aml_image="${tmp_path}/tmp_aml_image"
[[ -d "${make_path}" ]] || mkdir -p ${make_path}

# System operation environment
arch_info="$(uname -m)"
host_release="$(cat /etc/os-release | grep '^VERSION_CODENAME=.*' | cut -d'=' -f2)"
# Add personalized settings for special devices, such as [ s922x-oes-plus ]
board_release_file="etc/fnnas-board-release.conf"
# Add custom fnnas firmware information
ophub_release_file="etc/ophub-release"
# Add fnnas configuration file
fnnas_conf="etc/fnnas.conf"

# Dependency files download repository
depends_repo="https://github.com/ophub/amlogic-s9xxx-armbian"
# U-BOOT files download repository
uboot_repo="https://github.com/ophub/u-boot"
# Firmware files download repository
firmware_repo="https://github.com/ophub/firmware"

# Set the kernel download repository from github.com
kernel_repo="https://github.com/ophub/fnnas"
# Set the list of kernels used by default(Selectable version)
rockchip_kernel=("6.12.y")
amlogic_kernel=("6.12.y" "6.18.y")
allwinner_kernel=("6.12.y")
# Set to automatically use the latest kernel
auto_kernel="true"
# Initialize the kernel array
declare -A tags_list

# Set the Amlogic's u-boot series(u-boot-xxx.bin)
uboot_meson_gxl=("p201.bin" "p212.bin" "s905x-s912.bin" "n1.bin" "r3300l.bin")
uboot_meson_gxm=("p212.bin" "s905x-s912.bin" "zyxq.bin")
uboot_meson_g12a=("x96max.bin" "e900v22c.bin")
uboot_meson_g12b=("gtking.bin" "gtkingpro.bin" "gtkingpro-rev-a.bin" "s905x2-s922.bin")
uboot_meson_sm1=("x96maxplus.bin" "ugoos-x3.bin" "tx3-qz.bin" "tx3-bz.bin" "skyworth-lb2004.bin")
uboot_meson_gxbb=("p201.bin" "s905.bin")

# Initialize the build device
make_board="all"
# Set fnnas firmware size (Unit: MiB, boot_mb >= 512, root_mb >= 6144)
boot_mb="512"
root_mb="6144"
# Set automatic expansion size for the system root partition (Unit: GiB)
rootfs_expand="16"
# Set fnnas builder signature
builder_name="xcodebin"

# Set font color
STEPS="[\033[95m STEPS \033[0m]"
INFO="[\033[94m INFO \033[0m]"
NOTE="[\033[93m NOTE \033[0m]"
WARNING="[\033[93m WARNING \033[0m]"
SUCCESS="[\033[92m SUCCESS \033[0m]"
ERROR="[\033[91m ERROR \033[0m]"
#
#================================================================================================

error_msg() {
    echo -e " [ðŸ’”] ${1}"
    exit 1
}

process_msg() {
    echo -e " [ðŸŒ¿] ${1}"
}

mount_try() {
    # Check mount parameters
    m_type="${1}"
    m_dev="${2}"
    m_target="${3}"
    [[ -n "${m_type}" && -n "${m_dev}" && -n "${m_target}" ]] || {
        error_msg "Mount parameter is missing: [ ${m_type}, ${m_dev}, ${m_target} ]"
    }

    t="1"
    max_try="10"
    while [[ "${t}" -le "${max_try}" ]]; do
        # Mount according to the image partition format
        if [[ "${m_type}" == "btrfs" ]]; then
            mount -t ${m_type} -o discard,compress=zstd:1 ${m_dev} ${m_target} 2>/dev/null
        else
            mount -t ${m_type} -o discard ${m_dev} ${m_target} 2>/dev/null
        fi

        # Mount failed and continue trying
        if [[ "${?}" -eq 0 ]]; then
            break
        else
            sync && sleep 3
            umount -f ${m_target} 2>/dev/null
            ((t++))
        fi
    done
    [[ "${t}" -gt "${max_try}" ]] && error_msg "[ ${t} ] attempts to mount failed."
}

get_textoffset() {
    vmlinuz_name="${1}"
    need_overload="yes"
    # With TEXT_OFFSET patch is [ 0108 ], without TEXT_OFFSET patch is [ 0000 ]
    [[ "$(hexdump -n 15 -x "${vmlinuz_name}" 2>/dev/null | head -n 1 | awk '{print $7}')" == "0108" ]] && need_overload="no"
}

init_var() {
    echo -e "${STEPS} Start Initializing Variables..."

    # If it is followed by [ : ], it means that the option requires a parameter value
    local options="b:r:k:a:e:s:n:"
    parsed_args=$(getopt -o "${options}" -- "${@}")
    [[ ${?} -ne 0 ]] && error_msg "Parameter parsing failed."
    eval set -- "${parsed_args}"

    while true; do
        case "${1}" in
        -b | --Board)
            if [[ -n "${2}" ]]; then
                make_board="${2// /}"
                shift 2
            else
                error_msg "Invalid -b parameter [ ${2} ]!"
            fi
            ;;
        -r | --kernelRepository)
            if [[ -n "${2}" ]]; then
                kernel_repo="${2}"
                shift 2
            else
                error_msg "Invalid -r parameter [ ${2} ]!"
            fi
            ;;
        -k | --Kernel)
            if [[ -n "${2}" ]]; then
                oldIFS="${IFS}"
                IFS="_"
                amlogic_kernel=(${2})
                specific_kernel=(${2})
                IFS="${oldIFS}"
                shift 2
            else
                error_msg "Invalid -k parameter [ ${2} ]!"
            fi
            ;;
        -a | --Autokernel)
            if [[ -n "${2}" ]]; then
                auto_kernel="${2}"
                shift 2
            else
                error_msg "Invalid -a parameter [ ${2} ]!"
            fi
            ;;
        -e | --RootfsExpand)
            if [[ -n "${2}" ]]; then
                rootfs_expand="${2}"
                shift 2
            else
                error_msg "Invalid -e parameter [ ${2} ]!"
            fi
            ;;
        -s | --Size)
            if [[ -n "${2}" ]]; then
                img_mb="${2}"
                shift 2
            else
                error_msg "Invalid -s parameter [ ${2} ]!"
            fi
            ;;
        -n | --BuilderName)
            if [[ -n "${2}" ]]; then
                builder_name="${2// /}"
                shift 2
            else
                error_msg "Invalid -n parameter [ ${2} ]!"
            fi
            ;;
        --)
            shift
            break
            ;;
        *)
            [[ -n "${1}" ]] && error_msg "Invalid option [ ${1} ]!"
            break
            ;;
        esac
    done

    # Set the image size, such as [ -s 512/2560 ] or [ -s 2560 ]
    [[ -n "${img_mb}" ]] && {
        if [[ "${img_mb}" =~ / ]]; then
            boot_mb="${img_mb%%/*}"
            root_mb="${img_mb##*/}"
        else
            root_mb="${img_mb}"
        fi
    }
}

check_data() {
    # Columns of ${model_conf}:
    # 1.ID  2.MODEL  3.SOC  4.FDTFILE  5.UBOOT_OVERLOAD  6.MAINLINE_UBOOT  7.BOOTLOADER_IMG  8.DESCRIPTION
    # 9.KERNEL_TAGS  10.PLATFORM  11.FAMILY  12.BOOT_CONF  13.CONTRIBUTORS  14.BOARD  15.BUILD
    [[ -f "${model_conf}" ]] || error_msg "Missing model config file: [ ${model_conf} ]"

    # Get a list of build devices
    if [[ "${make_board}" =~ ^(all|first50|range50_100|range100_150|last20)$ ]]; then
        board_list=":(yes)"
        make_fnnas=($(
            cat ${model_conf} |
                sed -e 's/NA//g' -e 's/NULL//g' -e 's/[ ][ ]*//g' |
                grep -E "^[^#].*:yes$" | awk -F':' '{print $14}' |
                sort -u | xargs
        ))
    else
        board_list=":($(echo ${make_board} | sed -e 's/_/\|/g')):(yes|no)"
        make_fnnas=($(echo ${make_board} | sed -e 's/_/ /g'))
    fi
    [[ "${#make_fnnas[@]}" -eq 0 ]] && error_msg "The board is missing, stop making."

    # Select the first 50 boards
    [[ "${make_board}" == "first50" ]] && {
        make_fnnas=("${make_fnnas[@]:0:50}")
        board_list=":($(echo ${make_fnnas[@]} | sed -e 's/ /\|/g')):(yes|no)"
    }
    # Select boards from 51st to 100th
    [[ "${make_board}" == "range50_100" ]] && {
        make_fnnas=("${make_fnnas[@]:50:50}")
        board_list=":($(echo ${make_fnnas[@]} | sed -e 's/ /\|/g')):(yes|no)"
    }
    # Select boards from 101st to 150th
    [[ "${make_board}" == "range100_150" ]] && {
        make_fnnas=("${make_fnnas[@]:100:50}")
        board_list=":($(echo ${make_fnnas[@]} | sed -e 's/ /\|/g')):(yes|no)"
    }
    # Select the last 20 boards
    [[ "${make_board}" == "last20" ]] && {
        make_fnnas=("${make_fnnas[@]: -20}")
        board_list=":($(echo ${make_fnnas[@]} | sed -e 's/ /\|/g')):(yes|no)"
    }

    # Get the kernel array from the model configuration file
    kernel_from=($(
        cat ${model_conf} |
            sed -e 's/NA//g' -e 's/NULL//g' -e 's/[ ][ ]*//g' |
            grep -E "^[^#].*${board_list}$" | awk -F':' '{print $9}' |
            sort -u | xargs
    ))
    [[ "${#kernel_from[@]}" -eq 0 ]] && error_msg "Missing [ KERNEL_TAGS ] settings, stop building."

    # Convert the kernel_from to the kernel array
    for item in "${kernel_from[@]}"; do
        # Split the key and value
        IFS='/' read -r key value <<<"${item}"

        # Check if the value is "all".
        if [[ "${value}" == "all" ]]; then
            # If the value is "all", assign the value of ${key}_kernel. such as [ amlogic_kernel, rockchip_kernel, etc. ]
            eval "value=\"\${${key}_kernel[@]}\""
        elif [[ "${value}" =~ ^[1-9]+ ]]; then
            IFS='_' read -ra value <<<"${value}"
            value="${value[@]}"
        fi

        # If auto_kernel is false, use the value from -k parameter
        if [[ ! "${auto_kernel}" =~ ^(true|yes)$ ]]; then
            if [[ "${#specific_kernel[@]}" -eq 0 ]]; then
                error_msg "Plase use the -k parameter to specify the kernel version."
            else
                value="${specific_kernel[@]}"
            fi
        fi

        # Merge the same key values
        if [[ -n "${tags_list[${key}]}" ]]; then
            tags_list[${key}]+=" ${value}"
        else
            tags_list[${key}]="${value}"
        fi
    done

    # Convert the tags_list array to the kernel array (remove duplicates)
    for key in "${!tags_list[@]}"; do
        # Convert the space-separated string to an array and remove duplicates
        read -ra unique_values <<<"$(echo "${tags_list[${key}]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')"
        # Assign the unique values back to the tags_list
        tags_list[${key}]="${unique_values[@]}"
    done

    # Check the kernel tags list
    [[ "${#tags_list[@]}" -eq 0 ]] && error_msg "The [ tags_list ] is missing, stop building."
    echo -e "${INFO} The kernel tags list: [ ${!tags_list[@]} ]"

    # Convert kernel repository address to api format
    [[ "${kernel_repo}" =~ ^https: ]] && kernel_repo="$(echo ${kernel_repo} | awk -F'/' '{print $4"/"$5}')"
    kernel_api="https://github.com/${kernel_repo}"
}

find_fnnas() {
    cd ${current_path}
    echo -e "${STEPS} Start searching for fnnas file..."

    # Find whether the fnnas file exists
    fnnas_default_file="$(ls ${fnnas_path}/${fnnas_renas_file} 2>/dev/null | head -n 1 | awk -F "/" '{print $NF}')"
    if [[ -n "${fnnas_default_file}" ]]; then
        echo -e "${INFO} fnnas file: [ ${fnnas_default_file} ]"
    else
        error_msg "There is no [ ${fnnas_renas_file} ] file in the [ ${fnnas_path} ] directory."
    fi
}

git_pull_dir() {
    cd ${current_path}

    # Check git_pull_dir parameters
    git_repo="${1}"
    git_branch="${2}"
    git_path="${3}"
    [[ -n "${git_repo}" && -n "${git_branch}" && -n "${git_path}" ]] || {
        error_msg "git_pull_dir parameter is missing: [ ${git_repo}, ${git_branch}, ${git_path} ]"
    }

    # Clone the repository to the temporary directory. If it fails, wait 1 minute and try again, try 10 times.
    for i in {1..10}; do
        git clone --quiet --single-branch --depth=1 --branch=${git_branch} ${git_repo} ${git_path}
        [[ "${?}" -eq 0 ]] && break || sleep 60
    done
    [[ "${?}" -eq 0 ]] || error_msg "Failed to clone the [ ${git_repo} ] repository."
}

download_depends() {
    cd ${current_path}
    echo -e "${STEPS} Start downloading dependency files..."

    # Download u-boot files
    uboot_num="$(find "${uboot_path}/rockchip" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)"
    [[ -n "${uboot_num}" && "${uboot_num}" -le "5" ]] && {
        git_path="$(mktemp -d)"
        git_pull_dir ${uboot_repo} main ${git_path}
        # Move the u-boot files to the storage directory
        mkdir -p ${uboot_path}
        cp -af --no-preserve=ownership ${git_path}/u-boot/. ${uboot_path}
        [[ "${?}" -eq 0 ]] && echo -e "${INFO} fnnas: u-boot download completed." || error_msg "fnnas: u-boot download failed."
        # Delete temporary files
        rm -rf ${git_path}
    } || echo -e "${INFO} fnnas: u-boot directory is not empty, skip download."

    # Download firmware files
    firmware_num="$(find "${firmware_path}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)"
    [[ -n "${firmware_num}" && "${firmware_num}" -le "5" ]] && {
        git_path="$(mktemp -d)"
        git_pull_dir ${firmware_repo} main ${git_path}
        # Move the firmware files to the storage directory
        mkdir -p ${firmware_path}
        cp -af --no-preserve=ownership ${git_path}/firmware/. ${firmware_path}
        [[ "${?}" -eq 0 ]] && echo -e "${INFO} fnnas: firmware download completed." || error_msg "fnnas: firmware download failed."
        # Delete temporary files
        rm -rf ${git_path}
    } || echo -e "${INFO} fnnas: firmware directory is not empty, skip download."

    # Download Armbian repository files
    git_path="$(mktemp -d)"
    git_pull_dir ${depends_repo} main ${git_path}
    # Remove the special files in the [ sbin ] directory of the Armbian system
    find "${git_path}" -type d -path "*/platform-files/*/rootfs/usr/sbin" -prune -exec rm -rf {} +
    # Move the platform files to the storage directory
    cp -af --no-preserve=ownership ${git_path}/build-armbian/armbian-files/platform-files/. ${platform_files}
    [[ "${?}" -eq 0 ]] && echo -e "${INFO} fnnas: platform-files download completed." || error_msg "fnnas: platform-files download failed."
    # Move the different files to the storage directory
    cp -af --no-preserve=ownership ${git_path}/build-armbian/armbian-files/different-files/. ${different_files}
    [[ "${?}" -eq 0 ]] && echo -e "${INFO} fnnas: different-files download completed." || error_msg "fnnas: different-files download failed."
    # Delete temporary files
    rm -rf ${git_path}
}

query_kernel() {
    echo -e "${STEPS} Start querying the latest kernel version..."

    # Check the version on the kernel repository
    x="1"
    for key in "${!tags_list[@]}"; do
        {
            # Query the name of the latest kernel version
            tmp_arr_kernels=()
            down_kernel_list=(${tags_list[${key}]})
            i=1
            for kernel_var in "${down_kernel_list[@]}"; do
                echo -e "${INFO} (${x}.${i}) Auto query the latest kernel version for [ ${key} - ${kernel_var} ]"

                # Identify the kernel <VERSION> and <PATCHLEVEL>, such as [ 6.1 ]
                kernel_verpatch="$(echo ${kernel_var} | awk -F '.' '{print $1"."$2}')"

                # Query the latest kernel version
                latest_version="$(
                    curl -fsSL \
                        ${kernel_api}/releases/expanded_assets/kernel_fnnas |
                        grep -oP "${kernel_verpatch}\.[0-9]+(?=-${key}\.tar\.gz)" |
                        sort -urV | head -n 1
                )"

                if [[ "${?}" -eq 0 && -n "${latest_version}" ]]; then
                    tmp_arr_kernels[${i}]="${latest_version}"
                else
                    tmp_arr_kernels[${i}]="${kernel_var}"
                fi

                echo -e "${INFO} (${x}.${i}) [ ${key} - ${tmp_arr_kernels[$i]} ] is latest kernel. \n"

                ((i++))
            done

            # Assign the latest kernel version to the array
            tags_list[${key}]="${tmp_arr_kernels[@]}"

            ((x++))
        }
    done
}

check_kernel() {
    [[ -n "${1}" ]] && check_path="${1}" || error_msg "Invalid kernel path to check."
    check_files=($(cat "${check_path}/sha256sums" | awk '{print $2}'))
    for cf in "${check_files[@]}"; do
        {
            # Check if file exists
            [[ -s "${check_path}/${cf}" ]] || error_msg "The [ ${cf} ] file is missing."
            # Check if the file sha256sum is correct
            tmp_sha256sum="$(sha256sum "${check_path}/${cf}" | awk '{print $1}')"
            tmp_checkcode="$(cat ${check_path}/sha256sums | grep ${cf} | awk '{print $1}')"
            [[ "${tmp_sha256sum}" == "${tmp_checkcode}" ]] || error_msg "[ ${cf} ]: sha256sum verification failed."
        }
    done
    echo -e "${INFO} All [ ${#check_files[@]} ] kernel files are sha256sum checked to be complete.\n"
}

download_kernel() {
    cd ${current_path}
    echo -e "${STEPS} Start downloading the kernel files..."

    x="1"
    for key in "${!tags_list[@]}"; do
        {
            down_kernel_list=(${tags_list[${key}]})
            # Download the kernel to the storage directory
            i="1"
            for kernel_var in "${down_kernel_list[@]}"; do
                if [[ ! -d "${kernel_path}/${kernel_var}/${kernel_var}-${key}" ]]; then
                    kernel_down_from="https://github.com/${kernel_repo}/releases/download/kernel_fnnas/${kernel_var}-${key}.tar.gz"
                    echo -e "${INFO} (${x}.${i}) [ ${key} - ${kernel_var} ] Kernel download from [ ${kernel_down_from} ]"

                    # Download the kernel files. If the download fails, try again 10 times.
                    [[ -d "${kernel_path}/${key}" ]] || mkdir -p ${kernel_path}/${key}
                    [[ -d "${kernel_path}/${kernel_var}" ]] || mkdir -p ${kernel_path}/${kernel_var}
                    for t in {1..10}; do
                        curl -fsSL "${kernel_down_from}" -o "${kernel_path}/${key}/${kernel_var}-${key}.tar.gz"
                        [[ "${?}" -eq 0 ]] && break || sleep 60
                    done
                    [[ "${?}" -eq 0 ]] || error_msg "Failed to download the kernel files from the server."

                    # Decompress the kernel files
                    tar -mxzf "${kernel_path}/${key}/${kernel_var}-${key}.tar.gz" -C "${kernel_path}/${kernel_var}"
                    [[ "${?}" -eq 0 ]] || error_msg "[ ${kernel_var} ] kernel decompression failed."
                else
                    echo -e "${INFO} (${x}.${i}) [ ${key} - ${kernel_var} ] Kernel is in the local directory."
                fi

                # If the kernel contains the sha256sums file, check the files integrity
                [[ -f "${kernel_path}/${kernel_var}/${kernel_var}-${key}/sha256sums" ]] && {
                    check_kernel "${kernel_path}/${kernel_var}/${kernel_var}-${key}"
                }

                ((i++))
            done

            # Delete downloaded kernel temporary directory
            rm -rf ${kernel_path}/${key}
            sync

            ((x++))
        }
    done
}

confirm_version() {
    cd ${current_path}

    # Columns of ${model_conf}:
    # 1.ID  2.MODEL  3.SOC  4.FDTFILE  5.UBOOT_OVERLOAD  6.MAINLINE_UBOOT  7.BOOTLOADER_IMG  8.DESCRIPTION
    # 9.KERNEL_TAGS  10.PLATFORM  11.FAMILY  12.BOOT_CONF  13.CONTRIBUTORS  14.BOARD  15.BUILD
    # Column 5, called <UBOOT_OVERLOAD> in Amlogic, <TRUST_IMG> in Rockchip, Not used in Allwinner.

    # Find [ the first ] configuration information with [ the same BOARD name ] and [ BUILD as yes ] in the ${model_conf} file.
    board_conf="$(
        cat ${model_conf} |
            sed -e 's/NA//g' -e 's/NULL//g' -e 's/[ ][ ]*//g' |
            grep -E "^[^#].*:${board}:(yes|no)$" |
            head -n 1
    )"
    [[ -n "${board_conf}" ]] || error_msg "[ ${board} ] config is missing!"

    # Get device settings options
    MODEL_ID="$(echo ${board_conf} | awk -F':' '{print $1}')"
    MODEL_NAME="$(echo ${board_conf} | awk -F':' '{print $2}')"
    SOC="$(echo ${board_conf} | awk -F':' '{print $3}')"
    FDTFILE="$(echo ${board_conf} | awk -F':' '{print $4}')"
    UBOOT_OVERLOAD="$(echo ${board_conf} | awk -F':' '{print $5}')"
    TRUST_IMG="${UBOOT_OVERLOAD}"
    MAINLINE_UBOOT="$(echo ${board_conf} | awk -F':' '{print $6}')"
    BOOTLOADER_IMG="$(echo ${board_conf} | awk -F':' '{print $7}')"
    KERNEL_TAGS="$(echo ${board_conf} | awk -F':' '{print $9}')"
    PLATFORM="$(echo ${board_conf} | awk -F':' '{print $10}')"
    FAMILY="$(echo ${board_conf} | awk -F':' '{print $11}')"
    BOOT_CONF="$(echo ${board_conf} | awk -F':' '{print $12}')"
    CONTRIBUTORS="$(echo ${board_conf} | awk -F':' '{print $13}')"

    # Check whether the key parameters are correct
    [[ -n "${PLATFORM}" ]] || error_msg "Invalid PLATFORM parameter: [ ${PLATFORM} ]"
    # Set supported platform name
    support_platform=("amlogic" "rockchip" "allwinner")
    [[ -n "$(echo "${support_platform[@]}" | grep -w "${PLATFORM}")" ]] || error_msg "[ ${PLATFORM} ] not supported."

    # Add u-boot files record information
    [[ -n "${MAINLINE_UBOOT}" ]] && RECORD_MAINLINE_UBOOT="/usr/lib/u-boot/${MAINLINE_UBOOT}" || RECORD_MAINLINE_UBOOT=""
    [[ -n "${BOOTLOADER_IMG}" ]] && RECORD_BOOTLOADER_IMG="/usr/lib/u-boot/${BOOTLOADER_IMG}" || RECORD_BOOTLOADER_IMG=""
    [[ -n "${TRUST_IMG}" ]] && RECORD_TRUST_IMG="/usr/lib/u-boot/${TRUST_IMG}" || RECORD_TRUST_IMG=""
    # Set the Amlogic u-boot series
    family_rename="${FAMILY//-/_}"
    eval "amlogic_uboot=(\${uboot_${family_rename}[@]})"

    # Get the kernel tags and version
    conf_kernel_tags="${KERNEL_TAGS%%/*}"
    conf_kernel_list="${KERNEL_TAGS##*/}"
    # Check the kernel tags and version
    [[ -z "${conf_kernel_tags}" ]] && error_msg "The [ ${KERNEL_TAGS} ] is missing tags part."
    [[ -z "${conf_kernel_list}" ]] && error_msg "The [ ${KERNEL_TAGS} ] is missing list part."

    # Find the kernel list defined in the model database
    model_kernel=()
    if [[ "${conf_kernel_list}" == "all" ]]; then
        eval "model_kernel=(\"\${${conf_kernel_tags}_kernel[@]}\")"
        model_kernel=($(echo "${model_kernel[@]}" | xargs -n1 | sed -E 's/^([0-9]+\.[0-9]+)(\.[a-z0-9]+)?$/\1.[0-9]+/'))
    else
        # Convert the string into an array, using "_" as the delimiter
        IFS='_' read -ra conf_kernel_list <<<"${conf_kernel_list}"
        model_kernel=($(echo "${conf_kernel_list[@]}" | xargs -n1 | sed -E 's/^([0-9]+\.[0-9]+)(\.[a-z0-9]+)?$/\1.[0-9]+/'))
    fi
    # Check the kernel list
    [[ "${#model_kernel[@]}" -eq 0 ]] && error_msg "The kernel list is empty for [ ${board} ]"

    # Find the kernel version that matches the custom version
    build_kernel=()
    latest_kernel=(${tags_list[${conf_kernel_tags}]})
    for ck in "${model_kernel[@]}"; do
        for lk in "${latest_kernel[@]}"; do
            [[ "${lk}" =~ ^${ck}$ ]] && build_kernel+=("${lk}")
        done
    done
    # Check the kernel version
    [[ "${#build_kernel[@]}" -eq 0 ]] && error_msg "The kernel list is invalid for [ ${board} ]"
}

extract_fnnas() {
    process_msg "(1/7) Extract fnnas files."
    cd ${current_path}

    rm -rf ${tmp_path}
    mkdir -p ${tmp_outpath} ${tmp_fnnas} ${tmp_build} ${tmp_aml_image}

    fnnas_image_file="${tmp_aml_image}/fnnas_${board}_${kernel}.img"
    rm -f ${fnnas_image_file}
    cp -f "${fnnas_path}/${fnnas_default_file}" "${fnnas_image_file}"

    loop_old="$(losetup -P -f --show "${fnnas_image_file}")"
    [[ -n "${loop_old}" ]] || error_msg "losetup ${fnnas_image_file} failed."

    # Mount rootfs partition
    [[ -b "${loop_old}p2" ]] && mount_dev="${loop_old}p2" || mount_dev="${loop_old}p1"
    mount_try btrfs ${mount_dev} ${tmp_fnnas}

    cd ${tmp_fnnas}

    # Delete all files of /boot partition and replace it later
    rm -rf boot/*
    # Delete the kernel files and replace it later
    rm -rf usr/lib/modules/*
    # Delete apt cache files
    rm -rf var/cache/apt/archives/* var/cache/man/*
    # Delete the symbolic link files and relink it later
    rm -rf bin lib sbin var/lock var/run
    # Delete unused and duplicate scripts
    rm -f root/install* root/fstab.template
    rm -f usr/sbin/ddbr usr/bin/ddbr
}

make_image() {
    process_msg "(2/7) Make fnnas image."
    cd ${current_path}

    # Set fnnas image file parameters
    [[ "${PLATFORM}" == "amlogic" ]] && {
        skip_mb="4"
        partition_table_type="msdos"
        bootfs_type="fat32"
    }
    [[ "${PLATFORM}" == "rockchip" ]] && {
        skip_mb="16"
        partition_table_type="gpt"
        bootfs_type="ext4"
    }
    [[ "${PLATFORM}" == "allwinner" ]] && {
        skip_mb="16"
        partition_table_type="msdos"
        bootfs_type="fat32"
    }

    # Special procedures for flashing specific boards
    # Reset default parameters
    write_board_file="no"
    adjust_kernel_files="no"
    # Check the personalization settings of this board
    board_release="${different_files}/${board}/rootfs/${board_release_file}"
    [[ -f "${board_release}" ]] && source ${board_release}

    # echo -e "${INFO} The [ ${board} ] fnnas image partition status: [ skip:${skip_mb} / boot:${boot_mb} / rootfs:${root_mb} ] MiB."

    # Check output directory
    [[ -d "${out_path}" ]] || mkdir -p ${out_path}
    # Set fnnas image filename
    fnnas_filename="fnnas_${PLATFORM}_${board}_k${kernel}_$(date +"%Y.%m.%d").img"
    build_image_file="${out_path}/${fnnas_filename}"
    rm -f ${build_image_file}

    IMG_SIZE="$((skip_mb + boot_mb + root_mb))"
    truncate -s ${IMG_SIZE}M ${build_image_file} >/dev/null 2>&1

    parted -s ${build_image_file} mklabel ${partition_table_type} 2>/dev/null
    parted -s ${build_image_file} mkpart primary ${bootfs_type} $((skip_mb))MiB $((skip_mb + boot_mb - 1))MiB 2>/dev/null
    parted -s ${build_image_file} mkpart primary btrfs $((skip_mb + boot_mb))MiB 100% 2>/dev/null

    # Mount the fnnas image file
    loop_new="$(losetup -P -f --show "${build_image_file}")"
    [[ -n "${loop_new}" ]] || error_msg "losetup ${build_image_file} failed."

    # Confirm BOOT_UUID
    BOOT_UUID="$(cat /proc/sys/kernel/random/uuid)"
    [[ -z "${BOOT_UUID}" ]] && BOOT_UUID="$(uuidgen)"
    [[ -z "${BOOT_UUID}" ]] && error_msg "The uuidgen is invalid, cannot continue."
    FAT_ID_RAW=$(echo "${BOOT_UUID}" | tr -d '-' | cut -c1-8)
    FAT_ID_FSTAB=$(echo "${FAT_ID_RAW}" | awk '{print toupper(substr($0,1,4) "-" substr($0,5,4))}')
    # Confirm ROOTFS_UUID
    ROOTFS_UUID="$(cat /proc/sys/kernel/random/uuid)"
    [[ -z "${ROOTFS_UUID}" ]] && ROOTFS_UUID="$(uuidgen)"
    [[ -z "${ROOTFS_UUID}" ]] && error_msg "The uuidgen is invalid, cannot continue."

    # Format bootfs partition
    if [[ "${bootfs_type}" == "fat32" ]]; then
        mkfs.vfat -F 32 -i "${FAT_ID_RAW}" -n "BOOT" ${loop_new}p1 >/dev/null 2>&1
    else
        mkfs.ext4 -F -q -U ${BOOT_UUID} -L "BOOT" -b 4k -m 0 ${loop_new}p1 >/dev/null 2>&1
    fi

    # Format rootfs partition
    mkfs.btrfs -f -U ${ROOTFS_UUID} -L "ROOTFS" -m single ${loop_new}p2 >/dev/null 2>&1

    # Write the specific bootloader for [ Amlogic ] boxes
    [[ "${PLATFORM}" == "amlogic" ]] && {
        bootloader_path="${uboot_path}/${PLATFORM}/bootloader"
        if [[ -n "${MAINLINE_UBOOT}" && -f "${bootloader_path}/${MAINLINE_UBOOT}" ]]; then
            dd if="${bootloader_path}/${MAINLINE_UBOOT}" of="${loop_new}" conv=fsync bs=1 count=444 2>/dev/null
            dd if="${bootloader_path}/${MAINLINE_UBOOT}" of="${loop_new}" conv=fsync bs=512 skip=1 seek=1 2>/dev/null
            #echo -e "${INFO} 01. For [ ${board} ] write bootloader: ${MAINLINE_UBOOT}"
        elif [[ -n "${BOOTLOADER_IMG}" && -f "${bootloader_path}/${BOOTLOADER_IMG}" ]]; then
            dd if="${bootloader_path}/${BOOTLOADER_IMG}" of="${loop_new}" conv=fsync bs=1 count=444 2>/dev/null
            dd if="${bootloader_path}/${BOOTLOADER_IMG}" of="${loop_new}" conv=fsync bs=512 skip=1 seek=1 2>/dev/null
            #echo -e "${INFO} 02. For [ ${board} ] write bootloader: ${BOOTLOADER_IMG}"
        fi
    }

    # Write the specific bootloader for [ Rockchip ] boxes
    [[ "${PLATFORM}" == "rockchip" ]] && {
        bootloader_path="${uboot_path}/${PLATFORM}/${board}"
        if [[ -n "${BOOTLOADER_IMG}" && -f "${bootloader_path}/${BOOTLOADER_IMG}" ]] &&
            [[ -n "${MAINLINE_UBOOT}" && -f "${bootloader_path}/${MAINLINE_UBOOT}" ]] &&
            [[ -n "${TRUST_IMG}" && -f "${bootloader_path}/${TRUST_IMG}" ]]; then
            dd if="${bootloader_path}/${BOOTLOADER_IMG}" of="${loop_new}" conv=fsync,notrunc bs=512 seek=64 2>/dev/null
            dd if="${bootloader_path}/${MAINLINE_UBOOT}" of="${loop_new}" conv=fsync,notrunc bs=512 seek=16384 2>/dev/null
            dd if="${bootloader_path}/${TRUST_IMG}" of="${loop_new}" conv=fsync,notrunc bs=512 seek=24576 2>/dev/null
            #echo -e "${INFO} 01. For [ ${board} ] write bootloader: ${TRUST_IMG}"
        elif [[ -n "${BOOTLOADER_IMG}" && -f "${bootloader_path}/${BOOTLOADER_IMG}" ]] &&
            [[ -n "${MAINLINE_UBOOT}" && -f "${bootloader_path}/${MAINLINE_UBOOT}" ]]; then
            dd if="${bootloader_path}/${BOOTLOADER_IMG}" of="${loop_new}" conv=fsync,notrunc bs=512 seek=64 2>/dev/null
            dd if="${bootloader_path}/${MAINLINE_UBOOT}" of="${loop_new}" conv=fsync,notrunc bs=512 seek=16384 2>/dev/null
            #echo -e "${INFO} 02. For [ ${board} ] write bootloader: ${MAINLINE_UBOOT}"
        elif [[ "${BOOTLOADER_IMG}" == "u-boot-rockchip.bin" && -f "${bootloader_path}/${BOOTLOADER_IMG}" ]]; then
            dd if="${bootloader_path}/${BOOTLOADER_IMG}" of="${loop_new}" conv=fsync,notrunc bs=512 seek=64 2>/dev/null
            #echo -e "${INFO} 03. For [ ${board} ] write bootloader: ${BOOTLOADER_IMG}"
        elif [[ -n "${BOOTLOADER_IMG}" && -f "${bootloader_path}/${BOOTLOADER_IMG}" ]]; then
            dd if="${bootloader_path}/${BOOTLOADER_IMG}" of="${loop_new}" conv=fsync,notrunc bs=512 skip=64 seek=64 2>/dev/null
            #echo -e "${INFO} 04. For [ ${board} ] write bootloader: ${BOOTLOADER_IMG}"
        fi
    }

    # Write the specific bootloader for [ Allwinner ] boxes
    [[ "${PLATFORM}" == "allwinner" ]] && {
        bootloader_path="${uboot_path}/${PLATFORM}/${board}"
        if [[ -n "${BOOTLOADER_IMG}" && -f "${bootloader_path}/${BOOTLOADER_IMG}" ]] &&
            [[ -n "${MAINLINE_UBOOT}" && -f "${bootloader_path}/${MAINLINE_UBOOT}" ]]; then
            dd if="${bootloader_path}/${BOOTLOADER_IMG}" of="${loop_new}" conv=fsync,notrunc bs=8k seek=1 2>/dev/null
            dd if="${bootloader_path}/${MAINLINE_UBOOT}" of="${loop_new}" conv=fsync,notrunc bs=8k seek=5 2>/dev/null
            #echo -e "${INFO} 01. For [ ${board} ] write bootloader: ${MAINLINE_UBOOT}"
        elif [[ -n "${BOOTLOADER_IMG}" && -f "${bootloader_path}/${BOOTLOADER_IMG}" ]]; then
            dd if="${bootloader_path}/${BOOTLOADER_IMG}" of="${loop_new}" conv=fsync,notrunc bs=8k seek=1 2>/dev/null
            #echo -e "${INFO} 02. For [ ${board} ] write bootloader: ${BOOTLOADER_IMG}"
        fi
    }

    # Set partition names
    if [[ "${partition_table_type}" == "msdos" ]]; then
        dd if=/dev/urandom of="${loop_new}" bs=1 count=4 seek=440 conv=notrunc status=none
    elif [[ "${partition_table_type}" == "gpt" ]]; then
        parted -s "${build_image_file}" name 1 BOOT 2>/dev/null
        parted -s "${build_image_file}" name 2 ROOTFS 2>/dev/null
    fi

    # Special procedures for flashing specific boards
    [[ "${write_board_file}" == "yes" ]] && write_board_bootloader
}

copy_files() {
    process_msg "(3/7) Copy the fnnas files."
    cd ${current_path}

    # Create a dual-partition general directory
    tag_bootfs="${tmp_build}/bootfs"
    tag_rootfs="${tmp_build}/rootfs"
    mkdir -p ${tag_bootfs} ${tag_rootfs}
    chown root:root ${tag_bootfs} ${tag_rootfs}

    # Mount bootfs
    if [[ "${bootfs_type}" == "fat32" ]]; then
        mount_try vfat ${loop_new}p1 ${tag_bootfs}
    else
        mount_try ext4 ${loop_new}p1 ${tag_bootfs}
    fi

    # Mount rootfs
    mount_try btrfs ${loop_new}p2 ${tag_rootfs}

    # Copy the full fnnas image
    cp -af ${tmp_fnnas}/. ${tag_rootfs}

    # Copy the common files
    [[ -d "${common_files}" ]] && cp -af --no-preserve=ownership ${common_files}/. ${tag_rootfs}

    # Copy the platform files
    platform_bootfs="${platform_files}/${PLATFORM}/bootfs"
    platform_rootfs="${platform_files}/${PLATFORM}/rootfs"
    [[ -d "${platform_bootfs}" ]] && cp -rf ${platform_bootfs}/. ${tag_bootfs}
    [[ -d "${platform_rootfs}" ]] && cp -af --no-preserve=ownership ${platform_rootfs}/. ${tag_rootfs}

    # Copy the different files
    different_bootfs="${different_files}/${board}/bootfs"
    different_rootfs="${different_files}/${board}/rootfs"
    [[ -d "${different_bootfs}" ]] && cp -rf ${different_bootfs}/. ${tag_bootfs}
    [[ -d "${different_rootfs}" ]] && cp -af --no-preserve=ownership ${different_rootfs}/. ${tag_rootfs}

    # Copy the bootloader files
    [[ -d "${tag_rootfs}/usr/lib/u-boot" ]] || mkdir -p ${tag_rootfs}/usr/lib/u-boot
    rm -rf ${tag_rootfs}/usr/lib/u-boot/*
    [[ -d "${bootloader_path}" ]] && cp -af --no-preserve=ownership ${bootloader_path}/. ${tag_rootfs}/usr/lib/u-boot

    # Copy the Amlogic overload files
    [[ "${PLATFORM}" == "amlogic" ]] && {
        for au in "${amlogic_uboot[@]}"; do
            if [[ -f "${uboot_path}/${PLATFORM}/overload/u-boot-${au}" ]]; then
                cp -f ${uboot_path}/${PLATFORM}/overload/u-boot-${au} ${tag_bootfs}
            else
                error_msg "The [ u-boot-${au} ] file is missing in the [ ${uboot_path}/${PLATFORM}/overload ] directory."
            fi
        done
    }

    # Remove the .git directories
    rm -rf $(find ${tmp_build} -type d -name '.git')
}

replace_kernel() {
    process_msg "(4/7) Replace the kernel."
    cd ${current_path}

    # Determine custom kernel filename
    kernel_boot="$(ls ${kernel_path}/${kernel}/${kernel}-${PLATFORM}/boot-${PLATFORM}-${kernel}*.tar.gz 2>/dev/null | head -n 1)"
    [[ -n "${kernel_boot}" ]] || error_msg "Missing kernel boot file for [ ${kernel} ]"
    kernel_name="${kernel_boot##*/}"
    kernel_name="${kernel_name#boot-${PLATFORM}-}"
    kernel_name="${kernel_name%.tar.gz}"
    [[ -n "${kernel_name}" ]] || error_msg "Missing kernel files for [ ${kernel} ]"
    kernel_dtb="${kernel_path}/${kernel}/${kernel}-${PLATFORM}/dtb-${PLATFORM}-${kernel_name}.tar.gz"
    kernel_modules="${kernel_path}/${kernel}/${kernel}-${PLATFORM}/modules-${PLATFORM}-${kernel_name}.tar.gz"
    kernel_header="${kernel_path}/${kernel}/${kernel}-${PLATFORM}/header-${PLATFORM}-${kernel_name}.tar.gz"
    [[ -s "${kernel_boot}" && -s "${kernel_dtb}" && -s "${kernel_modules}" && -s "${kernel_header}" ]] || error_msg "The 4 kernel missing."

    # 01. For /boot five files
    tar -mxzf ${kernel_boot} -C ${tag_bootfs}
    [[ "${PLATFORM}" == "allwinner" ]] && (cd ${tag_bootfs} && cp -f uInitrd-${kernel_name} uInitrd && cp -f vmlinuz-${kernel_name} Image)
    [[ "${PLATFORM}" == "amlogic" ]] && (cd ${tag_bootfs} && cp -f uInitrd-${kernel_name} uInitrd && cp -f vmlinuz-${kernel_name} zImage)
    [[ "${PLATFORM}" == "rockchip" ]] && (cd ${tag_bootfs} && ln -sf uInitrd-${kernel_name} uInitrd && ln -sf vmlinuz-${kernel_name} Image)
    [[ "$(ls ${tag_bootfs}/*${kernel_name} -l 2>/dev/null | grep "^-" | wc -l)" -ge "2" ]] || error_msg "The /boot files is missing."
    [[ "${PLATFORM}" == "amlogic" ]] && get_textoffset "${tag_bootfs}/zImage"

    # 02. For /boot/dtb/${PLATFORM}/*
    [[ -d "${tag_bootfs}/dtb/${PLATFORM}" ]] || mkdir -p ${tag_bootfs}/dtb/${PLATFORM}
    tar -mxzf ${kernel_dtb} -C ${tag_bootfs}/dtb/${PLATFORM}
    [[ "${PLATFORM}" == "rockchip" ]] && ln -sf dtb ${tag_bootfs}/dtb-${kernel_name}
    [[ "$(ls ${tag_bootfs}/dtb/${PLATFORM} -l 2>/dev/null | grep "^-" | wc -l)" -ge "2" ]] || error_msg "/boot/dtb/${PLATFORM} files is missing."

    # 03. For /usr/src/linux-headers-${kernel_name}
    header_path="linux-headers-${kernel_name}"
    rm -rf ${tag_rootfs}/usr/src/linux-headers-* 2>/dev/null && mkdir -p "${tag_rootfs}/usr/src/${header_path}"
    tar -mxzf ${kernel_header} -C ${tag_rootfs}/usr/src/${header_path}
    [[ -d "${tag_rootfs}/usr/src/${header_path}/include" ]] || error_msg "/usr/src/${header_path}/include folder is missing."

    # 04. For /usr/lib/modules/${kernel_name}
    tar -mxzf ${kernel_modules} -C ${tag_rootfs}/usr/lib/modules
    (cd ${tag_rootfs}/usr/lib/modules/${kernel_name}/ && rm -f build source 2>/dev/null && ln -sf /usr/src/${header_path} build)
    [[ -d "${tag_rootfs}/usr/lib/modules/${kernel_name}" ]] || error_msg "/usr/lib/modules/${kernel_name} folder is missing."

    # Special procedures for flashing specific boards
    [[ "${adjust_kernel_files}" == "yes" ]] && adjust_kernel_files_cmd
}

refactor_bootfs() {
    process_msg "(5/7) Refactor bootfs files."
    cd ${tag_bootfs}

    # Process Amlogic series boot partition files
    [[ "${PLATFORM}" == "amlogic" && "${need_overload}" == "yes" ]] && {
        # Add u-boot.ext for Amlogic 5.10 kernel
        if [[ -n "${UBOOT_OVERLOAD}" && -f "${UBOOT_OVERLOAD}" ]]; then
            cp -f ${UBOOT_OVERLOAD} u-boot.ext
            chmod +x u-boot.ext
        elif [[ -z "${UBOOT_OVERLOAD}" || ! -f "${UBOOT_OVERLOAD}" ]]; then
            error_msg "${board} Board does not support using ${kernel} kernel, missing u-boot."
        fi
    }

    # Set uEnv.txt & extlinux.conf mount parameters
    uenv_rootdev="UUID=${ROOTFS_UUID} rootflags=compress=zstd:1 rw rootwait rootfstype=btrfs"
    # Set armbianEnv.txt mount parameters
    armbianenv_rootdev="UUID=${ROOTFS_UUID}"
    armbianenv_rootflags="compress=zstd:1"

    # Edit the uEnv.txt
    uenv_conf_file="uEnv.txt"
    [[ -f "${uenv_conf_file}" ]] && {
        sed -i "s|LABEL=ROOTFS|${uenv_rootdev}|g" ${uenv_conf_file}
        sed -i "s|meson.*.dtb|${FDTFILE}|g" ${uenv_conf_file}
        sed -i "s|sun.*.dtb|${FDTFILE}|g" ${uenv_conf_file}
        sed -i "s|rk.*.dtb|${FDTFILE}|g" ${uenv_conf_file}
    }

    # Add an alternate file (/boot/extlinux/extlinux.conf)
    boot_extlinux_file="extlinux/extlinux.conf.bak"
    rename_extlinux_file="extlinux/extlinux.conf"
    [[ -f "${boot_extlinux_file}" ]] && {
        sed -i "s|LABEL=ROOTFS|${uenv_rootdev}|g" ${boot_extlinux_file}
        sed -i "s|meson.*.dtb|${FDTFILE}|g" ${boot_extlinux_file}
        sed -i "s|sun.*.dtb|${FDTFILE}|g" ${boot_extlinux_file}
        sed -i "s|rk.*.dtb|${FDTFILE}|g" ${boot_extlinux_file}
        # If needed, such as t95z(s905x), rename delete .bak
        [[ "${BOOT_CONF}" == "extlinux.conf" ]] && mv -f ${boot_extlinux_file} ${rename_extlinux_file}
    }

    # Edit the armbianEnv.txt
    armbianenv_conf_file="armbianEnv.txt"
    [[ -f "${armbianenv_conf_file}" ]] && {
        sed -i "s|\(fdtfile=.*\/\)[^/]*$|\1${FDTFILE}|g" ${armbianenv_conf_file}
        sed -i "s|^rootdev=.*|rootdev=${armbianenv_rootdev}|g" ${armbianenv_conf_file}
        sed -i "s|^rootfstype=.*|rootfstype=btrfs|g" ${armbianenv_conf_file}
        sed -i "s|^rootflags=.*|rootflags=${armbianenv_rootflags}|g" ${armbianenv_conf_file}
        sed -i "s|^overlay_prefix=.*|overlay_prefix=${FAMILY}|g" ${armbianenv_conf_file}
    }

    # Check device configuration files
    [[ -f "${uenv_conf_file}" || -f "${rename_extlinux_file}" || -f "${armbianenv_conf_file}" ]] || error_msg "Missing [ /boot/*Env.txt ]"
}

refactor_rootfs() {
    process_msg "(6/7) Refactor rootfs files."
    cd ${tag_rootfs}

    # Disable update_initramfs
    initramfs_conf="etc/initramfs-tools/update-initramfs.conf"
    [[ -f "${initramfs_conf}" ]] && {
        [[ -n "$(cat ${initramfs_conf} | grep -oE "^update_initramfs=")" ]] || error_msg "Missing [ update_initramfs ]"
        sed -i "s|^update_initramfs=.*|update_initramfs=no|g" ${initramfs_conf}
    }

    # Delete related files
    rm -f var/lib/dpkg/info/linux-image*
    rm -rf usr/share/doc/linux-image-*
    rm -f usr/trim/bin/resize-rootfs.sh

    # Rebuild symbolic link files (ln -sf ${target} ${symbolic_link_file})
    ln -sf usr/bin bin
    ln -sf usr/lib lib
    ln -sf usr/sbin sbin
    ln -sf /run/lock var/lock
    ln -sf /run var/run
    ln -sf /usr/share/zoneinfo/Asia/Shanghai etc/localtime
    ln -sf fnnas-ddbr usr/sbin/ddbr
    ln -sf /usr/sbin/fnnas-tf usr/trim/bin/resize-rootfs.sh

    # Fix common releases permissions
    [[ -d "var/tmp" ]] && chmod 777 var/tmp
    [[ -d "var/cache/man" ]] && chown man:root var/cache/man -R
    [[ -d "var/cache/man" ]] && chmod g+s var/cache/man -R
    [[ -f "etc/sudoers" ]] && chown root:root etc/sudoers
    [[ -f "etc/sudoers" ]] && chmod 440 etc/sudoers
    [[ -f "usr/bin/sudo" ]] && chown root:root usr/bin/sudo
    [[ -f "usr/bin/sudo" ]] && chmod 4755 usr/bin/sudo
    # Fix focal permissions
    [[ -f "usr/lib/sudo/sudoers.so" ]] && chown 0 usr/lib/sudo/sudoers.so
    [[ -f "usr/lib/sudo/sudoers.so" ]] && chmod 644 usr/lib/sudo/sudoers.so
    [[ -f "usr/lib/policykit-1/polkit-agent-helper-1" ]] && chmod 4755 usr/lib/policykit-1/polkit-agent-helper-1
    # Fix jammy permissions
    [[ -f "usr/libexec/sudo/sudoers.so" ]] && chown 0 usr/libexec/sudo/sudoers.so
    [[ -f "usr/libexec/sudo/sudoers.so" ]] && chmod 644 usr/libexec/sudo/sudoers.so
    [[ -f "usr/libexec/polkit-agent-helper-1" ]] && chmod 4755 usr/libexec/polkit-agent-helper-1

    # Edit the etc/fstab
    echo "# <file system> <mount point>   <type>  <options>       <dump>  <pass>" >etc/fstab
    echo "UUID=${ROOTFS_UUID}       /      btrfs  defaults,noatime,compress=zstd:1    0 1" >>etc/fstab
    if [[ "${bootfs_type}" == "fat32" ]]; then
        echo "UUID=${FAT_ID_FSTAB}  /boot  vfat   defaults,noatime,errors=remount-ro  0 2" >>etc/fstab
    else
        echo "UUID=${BOOT_UUID}     /boot  ext4   defaults,noatime,errors=remount-ro  0 2" >>etc/fstab
    fi
    echo "tmpfs                     /tmp   tmpfs  defaults,nosuid  0 0" >>etc/fstab

    # Make the .bashrc take effect, Default shell settings file: /etc/default/useradd
    echo '[[ "${SHELL}" == *bash && -f "${HOME}/.bashrc" ]] && . ${HOME}/.bashrc' >>etc/profile

    # Set rootfs size limit in fnnas.conf
    [[ -f "${fnnas_conf}" ]] || error_msg "Missing fnnas configuration file: [ ${fnnas_conf} ]"
    rootfs_expand="$(echo "${rootfs_expand}" | tr -cd '0-9.' | cut -d. -f1)"
    [[ -z "${rootfs_expand}" || ! "${rootfs_expand}" =~ ^[0-9]+$ ]] && rootfs_expand="16"
    [[ "${rootfs_expand}" -ne "16" ]] && {
        sed -i "s|^rootfs_limit_gib=.*|rootfs_limit_gib=\"${rootfs_expand}\"|g" "${fnnas_conf}"
    }

    # Get random macaddr
    mac_hexchars="0123456789ABCDEF"
    mac_end=$(for i in {1..6}; do echo -n ${mac_hexchars:$((${RANDOM} % 16)):1}; done | sed -e 's/\(..\)/:\1/g')
    random_macaddr="9E:61${mac_end}"

    # Optimize wifi/bluetooth module
    [[ -d "usr/lib/firmware/brcm" ]] && (
        cd usr/lib/firmware/brcm/ && rm -f ../*.hcd

        # gtking/gtking pro is bcm4356 wifi/bluetooth, wifi5 module AP6356S
        sed -e "s/macaddr=.*/macaddr=${random_macaddr}:00/" "brcmfmac4356-sdio.txt" >"brcmfmac4356-sdio.azw,gtking.txt"
        # gtking/gtking pro is bcm4356 wifi/bluetooth, wifi6 module AP6275S
        sed -e "s/macaddr=.*/macaddr=${random_macaddr}:01/" "brcmfmac4375-sdio.txt" >"brcmfmac4375-sdio.azw,gtking.txt"
        # MXQ Pro+ is AP6330(bcm4330) wifi/bluetooth
        sed -e "s/macaddr=.*/macaddr=${random_macaddr}:02/" "brcmfmac4330-sdio.txt" >"brcmfmac4330-sdio.crocon,mxq-pro-plus.txt"
        # HK1 Box & H96 Max X3 is bcm54339 wifi/bluetooth
        sed -e "s/macaddr=.*/macaddr=${random_macaddr}:03/" "brcmfmac4339-sdio.ZP.txt" >"brcmfmac4339-sdio.amlogic,sm1.txt"
        # new ugoos x3 is brm43456
        sed -e "s/macaddr=.*/macaddr=${random_macaddr}:04/" "brcmfmac43456-sdio.txt" >"brcmfmac43456-sdio.amlogic,sm1.txt"
        # x96max plus v5.1 (ip1001m phy) adopts am7256 (brcm4354)
        sed -e "s/macaddr=.*/macaddr=${random_macaddr}:05/" "brcmfmac4354-sdio.txt" >"brcmfmac4354-sdio.amlogic,sm1.txt"
        # panther x2 AP6212A
        sed -e "s/macaddr=.*/macaddr=${random_macaddr}:06/" "brcmfmac43430-sdio.txt" >"brcmfmac43430-sdio.panther,x2.txt"
        # ct2000 s922x is brm4359
        sed -i "s/macaddr=.*/macaddr=${random_macaddr}:07/" "brcmfmac4359-sdio.ali,ct2000.txt"
    )

    # Add custom fnnas information
    echo "PLATFORM='${PLATFORM}'" >>${ophub_release_file}
    echo "VERSION_CODEID='${release_codeid}'" >>${ophub_release_file}
    echo "VERSION_CODENAME='${release_codename}'" >>${ophub_release_file}
    echo "MODEL_ID='${MODEL_ID}'" >>${ophub_release_file}
    echo "MODEL_NAME='${MODEL_NAME}'" >>${ophub_release_file}
    echo "SOC='${SOC}'" >>${ophub_release_file}
    echo "FDTFILE='${FDTFILE}'" >>${ophub_release_file}
    echo "FAMILY='${FAMILY}'" >>${ophub_release_file}
    echo "BOARD='${board}'" >>${ophub_release_file}
    echo "KERNEL_REPO='${kernel_repo}'" >>${ophub_release_file}
    echo "KERNEL_TAGS='kernel_fnnas'" >>${ophub_release_file}
    echo "KERNEL_VERSION='${kernel}'" >>${ophub_release_file}
    echo "KERNEL_BACKUP='yes'" >>${ophub_release_file}
    echo "BOOT_CONF='${BOOT_CONF}'" >>${ophub_release_file}
    echo "ROOTFS_TYPE='btrfs'" >>${ophub_release_file}
    echo "DISK_TYPE='usb'" >>${ophub_release_file}
    echo "AMPART_STATUS='no'" >>${ophub_release_file}
    echo "MLUBOOT_STATUS='no'" >>${ophub_release_file}
    echo "MAINLINE_UBOOT='${RECORD_MAINLINE_UBOOT}'" >>${ophub_release_file}
    echo "BOOTLOADER_IMG='${RECORD_BOOTLOADER_IMG}'" >>${ophub_release_file}
    if [[ "${PLATFORM}" == "rockchip" ]]; then
        echo "TRUST_IMG='${RECORD_TRUST_IMG}'" >>${ophub_release_file}
    elif [[ "${PLATFORM}" == "amlogic" ]]; then
        echo "UBOOT_OVERLOAD='${UBOOT_OVERLOAD}'" >>${ophub_release_file}
    fi
    echo "FNNAS_WEBSITE='fnnas.com'" >>${ophub_release_file}
    echo "REBUILD_REPOSITORY='github.com/ophub/fnnas'" >>${ophub_release_file}
    echo "CONTRIBUTORS='${CONTRIBUTORS}'" >>${ophub_release_file}
    echo "BUILDER_NAME='${builder_name}'" >>${ophub_release_file}
    echo "PACKAGED_DATE='$(date +%Y-%m-%d)'" >>${ophub_release_file}

    sync && sleep 3
}

clean_tmp() {
    process_msg "(7/7) Cleanup tmp files."
    cd ${current_path}

    umount -f ${tmp_fnnas} 2>/dev/null
    losetup -d ${loop_old} 2>/dev/null

    # Unmount the fnnas image file
    fstrim ${tag_bootfs} 2>/dev/null
    fstrim ${tag_rootfs} 2>/dev/null
    umount -f ${tag_bootfs} 2>/dev/null
    umount -f ${tag_rootfs} 2>/dev/null
    losetup -d ${loop_new} 2>/dev/null

    cd ${out_path}
    # Compress the fnnas image file
    pigz -qf ${fnnas_filename} || gzip -qf ${fnnas_filename}

    cd ${current_path}
    # Clear temporary files directory
    rm -rf ${tmp_path} && sync
}

loop_make() {
    cd ${current_path}
    echo -e "${STEPS} Start making fnnas system..."

    j="1"
    for b in "${make_fnnas[@]}"; do
        {
            # Set specific configuration for making fnnas system
            board="${b}"
            confirm_version

            i="1"
            for k in "${build_kernel[@]}"; do
                {
                    # Set the kernel version
                    kernel="${k}"

                    # Check disk space size
                    echo -ne "(${j}.${i}) Start making fnnas [\033[92m ${board} - ${kernel} \033[0m]. "
                    now_remaining_space="$(df -Tk ${make_path} | tail -n1 | awk '{print $5}' | echo $(($(xargs) / 1024 / 1024)))"
                    if [[ "${now_remaining_space}" -le "10" ]]; then
                        echo -e "${WARNING} Remaining space is less than 10G, exit this make."
                        break
                    else
                        echo "Remaining space is ${now_remaining_space}G."
                    fi

                    # Execute the following functions in sequence
                    extract_fnnas
                    make_image
                    copy_files
                    replace_kernel
                    refactor_bootfs
                    refactor_rootfs
                    clean_tmp

                    echo -e "(${j}.${i}) fnnas made successfully. \n"
                    ((i++))
                }
            done

            ((j++))
        }
    done
}

# Show welcome message
echo -e "${STEPS} Welcome to make fnnas!"
echo -e "${INFO} Server running on Ubuntu: [ Release: ${host_release} / Host: ${arch_info} ] \n"
# Check script permission
[[ "$(id -u)" == 0 ]] || error_msg "please run this script as root: [ sudo ./${0} ]"

# Initialize variables and download the kernel
init_var "${@}"
check_data
# Find fnnas file
find_fnnas
# Download the dependency files
download_depends
# Query the latest kernel version
[[ "${auto_kernel}" =~ ^(true|yes)$ ]] && query_kernel
# Download the kernel files
download_kernel

# Show make settings
echo -e "${INFO} [ ${#make_fnnas[@]} ] lists of fnnas board: [ $(echo ${make_fnnas[@]} | xargs) ]"
echo -e "${INFO} Kernel Repo: [ ${kernel_repo} ], Kernel from: [ $(echo ${kernel_from[@]} | xargs) ] \n"
# Show server start information
echo -e "${INFO} Server space usage before starting to compile: \n$(df -hT ${make_path}) \n"

# Loop to make fnnas firmware
loop_make

# Show server end information
echo -e "${STEPS} Server space usage after compilation: \n$(df -hT ${make_path}) \n"
echo -e "${SUCCESS} All process completed successfully."
