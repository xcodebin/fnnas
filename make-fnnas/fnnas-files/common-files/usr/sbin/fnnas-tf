#!/bin/bash
#===========================================================================
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.
#
# This file is a part of the remake fnnas
# https://github.com/ophub/fnnas
#
# Function: Partition Expansion Tool
# Copyright (C) 2021- https://github.com/unifreq/openwrt_packit
# Copyright (C) 2021- https://github.com/ophub/fnnas
#
# Command: fnnas-tf
#
#========================= Set default parameters ==========================
#
# Load configuration file
fnnas_conf="/etc/fnnas.conf"

# Set font color
STEPS="[\033[95m STEPS \033[0m]"
INFO="[\033[94m INFO \033[0m]"
SUCCESS="[\033[92m SUCCESS \033[0m]"
OPTIONS="[\033[93m OPTIONS \033[0m]"
WARNING="[\033[93m WARNING \033[0m]"
ERROR="[\033[91m ERROR \033[0m]"
#
#===========================================================================

# Encountered a serious error, abort the script execution
error_msg() {
    echo -e "${ERROR} ${1}"
    exit 1
}

# Initialize variables
init_var() {
    if [[ -f "${fnnas_conf}" ]]; then
        source "${fnnas_conf}"
    else
        # Set root partition size limit (Unit: GiB)
        echo "rootfs_limit_gib=\"16\"" >"${fnnas_conf}"
        echo "rootfs_resize=\"yes\"" >>"${fnnas_conf}"
        rootfs_limit_gib="16"
        rootfs_resize="yes"
    fi
    # Ensure variables are set
    [[ -n "${rootfs_limit_gib}" ]] || rootfs_limit_gib="16"
    [[ -n "${rootfs_resize}" ]] || rootfs_resize="yes"
}

# Disable the resize-rootfs service
disable_service() {
    if systemctl is-enabled resize-rootfs.service >/dev/null 2>&1; then
        systemctl disable resize-rootfs.service >/dev/null 2>&1
        echo "Service resize-rootfs.service disabled"
    fi

    # Update configuration to prevent future resizing
    sed -i "s|^rootfs_resize=.*|rootfs_resize=\"no\"|g" "${fnnas_conf}"
}

# Check disk
do_checkdisk() {
    # Find the partition where root is located
    ROOT_PATH="$(df -P / | tail -n1 | awk '{print $1}')"
    # Extract only the name (e.g., mmcblk0p2)
    ROOT_PTNAME="$(basename "${ROOT_PATH}")"
    [[ -z "${ROOT_PTNAME}" ]] && error_msg "Cannot find the partition corresponding to the root file system!"

    # Find the disk and partition number
    case "${ROOT_PTNAME}" in
    mmcblk?p[0-9]*)
        # mmcblk0p2 -> DISK: mmcblk0, PART: 2
        DISK_NAME=$(echo "${ROOT_PTNAME}" | sed -E 's/p[0-9]+$//')
        PART_NUM=$(echo "${ROOT_PTNAME}" | grep -oE '[0-9]+$')
        ;;
    [hsv]d[a-z][0-9]*)
        # sda2 -> DISK: sda, PART: 2
        DISK_NAME=$(echo "${ROOT_PTNAME}" | sed -E 's/[0-9]+$//')
        PART_NUM=$(echo "${ROOT_PTNAME}" | grep -oE '[0-9]+$')
        ;;
    nvme?n?p[0-9]*)
        # nvme0n1p2 -> DISK: nvme0n1, PART: 2
        DISK_NAME=$(echo "${ROOT_PTNAME}" | sed -E 's/p[0-9]+$//')
        PART_NUM=$(echo "${ROOT_PTNAME}" | grep -oE '[0-9]+$')
        ;;
    *)
        error_msg "Unrecognized disk type ${ROOT_PTNAME}!"
        ;;
    esac

    echo -e "${INFO} Target Disk: [ ${DISK_NAME} ], Root Partition: [ ${PART_NUM} ]"
    sync && sleep 3
}

# Expand the current partition
expansion_partition() {
    echo -e "${INFO} Start repairing hard disk size..."

    # Try to fix GPT backup header location
    printf 'f\n' | parted ---pretend-input-tty /dev/${DISK_NAME} unit s print >/dev/null 2>&1
    [[ "${?}" -eq "0" ]] && echo -e "${INFO} GPT Header check complete."

    # Check partition count
    pt_num="$(parted -s /dev/${DISK_NAME} print 2>/dev/null | awk '$1~/[1-9]+/ {print $1}' | wc -l)"
    [[ "${pt_num}" -ne "2" ]] && echo -e "${WARNING} Partition count is ${pt_num}, expected 2. Proceeding anyway..."

    # Convert limit to bytes
    LIMIT_BYTES=$((rootfs_limit_gib * 1024 * 1024 * 1024))

    # Get disk size in bytes
    DISK_SIZE_BYTES="$(lsblk -b -n -o SIZE -d "/dev/${DISK_NAME}")"
    [[ "${DISK_SIZE_BYTES}" =~ ^[0-9]+$ ]] || DISK_SIZE_BYTES="0"

    # Check disk size and select expansion strategy
    if [[ "${DISK_SIZE_BYTES}" -gt "${LIMIT_BYTES}" ]]; then
        echo -e "${INFO} Strategy: Limit partition ${PART_NUM} to ${rootfs_limit_gib}GiB..."
        printf 'Yes\n\n' | parted ---pretend-input-tty /dev/${DISK_NAME} resizepart ${PART_NUM} ${rootfs_limit_gib}GiB
    else
        echo -e "${INFO} Strategy: Expand partition ${PART_NUM} to 100% (Full Disk)..."
        printf 'Yes\n-1\n' | parted ---pretend-input-tty /dev/${DISK_NAME} resizepart ${PART_NUM} 100%
    fi

    # Inform the kernel of partition table changes
    partprobe /dev/${DISK_NAME} 2>/dev/null
    sync && sleep 3

    echo -e "${INFO} Expansion file system..."
    ROOTFS_TYPE="$(df -T / | tail -n1 | awk '{print $2}')"

    if [[ "${ROOTFS_TYPE}" == "btrfs" ]]; then
        btrfs filesystem resize max /
        [[ "${?}" -ne "0" ]] && error_msg "[ btrfs ] operation failed."
    else
        resize2fs /dev/${ROOT_PTNAME}
        [[ "${?}" -ne "0" ]] && error_msg "[ resize2fs ] operation failed."
    fi

    echo -e "${SUCCESS} The current partition expansion is successful."
}

# Show welcome message
echo -e "${STEPS} Welcome to Partition Expansion Tool."
# Check for root privileges
[[ "$(id -u)" -ne "0" ]] && error_msg "This script must be run as root!"
# Initialize variables
init_var
# Check if root filesystem auto-resize is disabled
[[ "${rootfs_resize}" == "yes" ]] || {
    echo -e "${INFO} Root filesystem auto-resize is disabled in configuration. Exiting."
    exit 0
}
# Check disk and partition info
do_checkdisk
# Expand partition
expansion_partition
# Disable service
disable_service
